/** \mainpage Librería NSDSP - Procesamiento Digital de Señales No Estacionarias
 *
 * \section intro Introducción
 * 
 * NSDSP es una librería de procesamiento digital de señales diseñada para sistemas embebidos
 * y aplicaciones en tiempo real. La librería está optimizada para:
 * - Uso de memoria estática (sin asignación dinámica)
 * - Procesamiento muestra a muestra
 * - Múltiples instancias concurrentes de cada recurso
 * - Arquitectura modular y extensible
 *
 * \section arquitectura Arquitectura General
 *
 * \dot
 * digraph G {
 *   rankdir=TB;
 *   node [shape=box, style=filled];
 *   
 *   subgraph cluster_app {
 *     label="Aplicación de Usuario";
 *     style=dashed;
 *     APP [label="main.c", fillcolor=lightgreen];
 *   }
 *   
 *   subgraph cluster_nsdsp {
 *     label="Librería NSDSP";
 *     style=filled;
 *     fillcolor=lightgray;
 *     
 *     NSDSP [label="NSDSP.h/c", fillcolor=lightblue];
 *     STAT [label="nsdsp_statistical.h", fillcolor=lightyellow];
 *     MATH [label="nsdsp_math.h/c", fillcolor=lightcyan];
 *     ANN [label="ann.h/c", fillcolor=lightpink];
 *     
 *     subgraph cluster_resources {
 *       label="Recursos Disponibles";
 *       RT [label="RT_Momentos", fillcolor=lightcoral];
 *       DWT [label="DWT Transform", fillcolor=lightpink];
 *       FIR [label="FIR Filter", fillcolor=lightcyan];
 *       LAG [label="Lagrange Halfband", fillcolor=lightgray];
 *     }
 *   }
 *   
 *   APP -> NSDSP [label="include"];
 *   NSDSP -> STAT;
 *   NSDSP -> MATH;
 *   NSDSP -> ANN;
 *   NSDSP -> RT;
 *   NSDSP -> DWT;
 *   NSDSP -> FIR;
 *   NSDSP -> LAG;
 *   STAT -> RT [label="vista de datos", style=dashed];
 *   DWT -> FIR [label="usa"];
 *   DWT -> LAG [label="usa"];
 *   ANN -> MATH [label="usa matrices"];
 * }
 * \enddot
 *
 * \section servicios Servicios Disponibles
 *
 * \subsection rt_momentos RT_Momentos - Cálculo de Momentos Estadísticos
 * 
 * Calcula en tiempo real los 4 primeros momentos estadísticos de una señal:
 * - **Media (M1)**: Valor promedio de la señal
 * - **Varianza (M2)**: Dispersión de los valores respecto a la media
 * - **Asimetría (M3)**: Medida de la asimetría de la distribución
 * - **Curtosis (M4)**: Medida del apuntamiento de la distribución
 *
 * **Características:**
 * - Hasta 4 instancias concurrentes (MAX_RT_MOMENTOS)
 * - Ventana de muestras configurable (N_MA = 64)
 * - Procesamiento muestra a muestra en tiempo real
 * - Protección contra división por cero
 *
 * \subsection dwt_transform DWT - Transformada Wavelet Discreta
 * 
 * Implementa la descomposición wavelet mediante el algoritmo de Mallat:
 * - **Niveles configurables**: WAVELET_LEVELS (por defecto 2)
 * - **Tipos de filtro**: Lagrange, Daubechies 4, Daubechies 8
 * - **Salidas**: Coeficientes de aproximación y detalle por nivel
 * - **Múltiples objetos**: Tantos como memoria disponible
 *
 * \subsection fir_filter FIR Filter - Filtrado FIR de Propósito General
 * 
 * Módulo general de filtrado FIR con buffer circular:
 * - **Longitud configurable**: Hasta MAX_FIR_LENGTH coeficientes
 * - **Buffer circular eficiente**: Optimizado para tiempo real
 * - **Múltiples instancias**: Tantas como memoria disponible
 * - **Coeficientes definidos por usuario**: Máxima flexibilidad
 *
 * \subsection lagrange_halfband Lagrange Halfband - Filtros de Media Banda
 * 
 * Genera coeficientes para filtros de media banda de Lagrange:
 * - **Parámetro M configurable**: Controla el orden del filtro (4M-2)
 * - **Eficiencia computacional**: Mitad de coeficientes son cero
 * - **Uso en DWT**: Integrado con la transformada wavelet
 * - **Generación automática**: Coeficientes calculados matemáticamente
 *
 * \subsection nsdsp_math NSDSP Math - Operaciones Matemáticas
 * 
 * Proporciona operaciones matemáticas avanzadas para procesamiento de señales:
 * - **Multiplicación de matrices**: Producto matricial optimizado
 * - **Suma/Resta de matrices**: Operaciones elemento a elemento con control de signo
 * - **API estructurada**: Acceso mediante punteros a funciones
 * - **Validación completa**: Verificación de dimensiones y punteros
 * - **Gestión de errores**: Manejo robusto de casos excepcionales
 *
 * **Características:**
 * - Operaciones con matrices de cualquier dimensión
 * - Memoria estática (sin malloc/free)
 * - Retorno de códigos de error
 * - Compatible con sistemas embebidos
 *
 * \subsection ann_networks ANN - Redes Neuronales Artificiales
 * 
 * Implementa redes neuronales feedforward con múltiples funciones de activación:
 * - **Funciones de activación soportadas**: Sigmoid, Tanh, ReLU, Leaky ReLU, Softmax, Step
 * - **Arquitectura configurable**: Hasta LMAX (4) capas
 * - **Integración con NSDSP Math**: Usa operaciones matriciales optimizadas
 * - **Memoria estática**: Sin asignación dinámica
 *
 * **Características:**
 * - Creación de redes con matrices de pesos y bias predefinidas
 * - Soporte para diferentes topologías de red
 * - Vectores de entrada/salida configurables
 * - Compatible con sistemas embebidos en tiempo real
 *
 * \section patron Patrón de Uso de Recursos
 *
 * Los recursos de NSDSP siguen diferentes patrones según su tipo:
 *
 * \subsection patron_servicios Patrón de Servicios (RT_Momentos)
 *
 * \dot
 * digraph usage_services {
 *   rankdir=LR;
 *   node [shape=box, style=rounded];
 *   
 *   INIT [label="Init_RT_Momentos()", style=filled, fillcolor=lightgreen];
 *   SUB [label="pse.suscribe_rt_momentos()", style=filled, fillcolor=lightyellow];
 *   COMP [label="pse.compute_rt_momentos()", style=filled, fillcolor=lightblue];
 *   UNSUB [label="pse.unsuscribe_rt_momentos()", style=filled, fillcolor=lightcoral];
 *   
 *   INIT -> SUB [label="1"];
 *   SUB -> COMP [label="2"];
 *   COMP -> COMP [label="3\nrepetir"];
 *   COMP -> UNSUB [label="4"];
 * }
 * \enddot
 *
 * \subsection patron_objetos Patrón de Objetos (DWT, FIR, ANN)
 *
 * \dot
 * digraph usage_objects {
 *   rankdir=LR;
 *   node [shape=box, style=rounded];
 *   
 *   INIT_API [label="Init_[Module]()", style=filled, fillcolor=lightgreen];
 *   CREATE [label="[module]_api.get_[object]()", style=filled, fillcolor=lightyellow];
 *   USE [label="[module]_api.[function]()", style=filled, fillcolor=lightblue];
 *   
 *   INIT_API -> CREATE [label="1"];
 *   CREATE -> USE [label="2"];
 *   USE -> USE [label="3\nrepetir"];
 * }
 * \enddot
 *
 * \subsection patron_api Patrón de API (NSDSP Math)
 *
 * \dot
 * digraph usage_api {
 *   rankdir=LR;
 *   node [shape=box, style=rounded];
 *   
 *   INIT [label="nsdsp_math_init()", style=filled, fillcolor=lightgreen];
 *   CREATE_DATA [label="Crear objetos MATRIZ", style=filled, fillcolor=lightyellow];
 *   CALL_API [label="nsdsp_math_api.product()\nnsdsp_math_api.suma()", style=filled, fillcolor=lightblue];
 *   CHECK [label="Verificar resultado", shape=diamond, fillcolor=lightcyan];
 *   
 *   INIT -> CREATE_DATA [label="1"];
 *   CREATE_DATA -> CALL_API [label="2"];
 *   CALL_API -> CHECK [label="3"];
 * }
 * \enddot
 *
 * \subsection patron_ann Patrón de Objetos ANN
 *
 * \dot
 * digraph usage_ann {
 *   rankdir=LR;
 *   node [shape=box, style=rounded];
 *   
 *   INIT [label="Init_ANN()", style=filled, fillcolor=lightgreen];
 *   CREATE_WEIGHTS [label="Crear matrices\nde pesos y bias", style=filled, fillcolor=lightyellow];
 *   GET_SERVICE [label="ann_api.get_ann()", style=filled, fillcolor=lightblue];
 *   CONFIG_IO [label="Configurar\nx0 e y0", style=filled, fillcolor=lightcyan];
 *   PROCESS [label="Procesar datos\ncon la red", style=filled, fillcolor=lightpink];
 *   
 *   INIT -> CREATE_WEIGHTS [label="1"];
 *   CREATE_WEIGHTS -> GET_SERVICE [label="2"];
 *   GET_SERVICE -> CONFIG_IO [label="3"];
 *   CONFIG_IO -> PROCESS [label="4"];
 *   PROCESS -> PROCESS [label="5\nrepetir"];
 * }
 * \enddot
 *
 * \subsection patron_utilitarios Patrón de Utilitarios (Lagrange)
 *
 * \dot
 * digraph usage_utilities {
 *   rankdir=LR;
 *   node [shape=box, style=rounded];
 *   
 *   CALL [label="lagrange_halfband(m, h0)", style=filled, fillcolor=lightblue];
 *   USE [label="Usar coeficientes", style=filled, fillcolor=lightgreen];
 *   
 *   CALL -> USE [label="directo"];
 * }
 * \enddot
 *
 * \section dependencias Dependencias
 *
 * **Librerías estándar requeridas:**
 * - stdio.h (para definiciones básicas)
 * - stdlib.h (para tipos estándar)
 * - math.h (para funciones matemáticas: sqrt, sin, cos, log)
 * - stddef.h (para NULL y tipos de punteros)
 *
 * **Requisitos del compilador:**
 * - Soporte para C89/C90 o superior
 * - Soporte para punto flotante (float)
 *
 * **Requisitos de memoria (estimados):**
 * - RT_Momentos: ~4KB (4 servicios × 4 buffers × 64 muestras × 4 bytes)
 * - DWT: Variable según BUFFER_SIZE y WAVELET_LEVELS
 * - FIR: Variable según número de coeficientes por filtro
 * - NSDSP Math: Variable según tamaño de matrices utilizadas
 * - ANN: Variable según número de capas y neuronas por capa
 *
 * \section uso Como Usar la Librería
 *
 * \subsection paso1 Paso 1: Incluir el archivo principal
 * \code
 * #include "nsdsp.h"
 * \endcode
 *
 * \subsection paso2 Paso 2: Inicializar la librería
 * \code
 * int main(void)
 * {
 *     // Inicializar todos los recursos
 *     Init_NSDSP();
 * \endcode
 *
 * \subsection paso3_momentos Paso 3a: Usar RT_Momentos (Patrón de Servicios)
 * \code
 *     // Suscribirse a un servicio de momentos
 *     RT_MOMENTOS_SERVICE servicio;
 *     servicio = pse.suscribe_rt_momentos();
 *     
 *     if (servicio == NONE)
 *     {
 *         // No hay servicios disponibles
 *         return -1;
 *     }
 *     
 *     // Procesar muestras de señal
 *     float muestra;
 *     int resultado;
 *     
 *     while (/* condición de procesamiento */)
 *     {
 *         muestra = obtener_muestra();  // Tu función para obtener datos
 *         
 *         // Calcular momentos
 *         resultado = pse.compute_rt_momentos(servicio, muestra);
 *         
 *         // Leer resultados desde nsdsp_statistical_objects[]
 *         printf("Media: %f\n", nsdsp_statistical_objects[servicio].media);
 *         printf("Varianza: %f\n", nsdsp_statistical_objects[servicio].varianza);
 *         printf("Asimetría: %f\n", nsdsp_statistical_objects[servicio].asimetria);
 *         printf("Curtosis: %f\n", nsdsp_statistical_objects[servicio].curtosis);
 *     }
 *     
 *     // Liberar el servicio
 *     pse.unsuscribe_rt_momentos(servicio);
 * \endcode
 *
 * \subsection paso3_dwt Paso 3b: Usar DWT (Patrón de Objetos)
 * \code
 *     // Crear objeto DWT
 *     DWT_OBJECT dwt_obj;
 *     dwt_api.get_dwt(&dwt_obj);
 *     
 *     // Procesar muestras
 *     for (int i = 0; i < 1000; i++)
 *     {
 *         float muestra = obtener_muestra();
 *         dwt_api.dwt(muestra, &dwt_obj);
 *         
 *         // Leer salidas
 *         printf("Aproximación: %f\n", dwt_obj.yout[WAVELET_LEVELS]);
 *         for (int j = 0; j < WAVELET_LEVELS; j++)
 *         {
 *             printf("Detalle[%d]: %f\n", j, dwt_obj.yout[j]);
 *         }
 *     }
 * \endcode
 *
 * \subsection paso3_fir Paso 3c: Usar FIR Filter (Patrón de Objetos)
 * \code
 *     // Definir coeficientes del filtro
 *     float coefs[5] = {0.2f, 0.2f, 0.2f, 0.2f, 0.2f}; // Filtro promediador
 *     float z_buffer[5];
 *     
 *     // Crear objeto FIR
 *     FIR_FILTER_OBJECT filtro = fir_api.get_fir(5, coefs, z_buffer);
 *     
 *     // Procesar muestras
 *     for (int i = 0; i < 1000; i++)
 *     {
 *         float muestra = obtener_muestra();
 *         float salida = fir_api.fir_filter(muestra, &filtro);
 *         procesar_salida(salida);
 *     }
 * \endcode
 *
 * \subsection paso3_math Paso 3d: Usar NSDSP Math (Patrón de API)
 * \code
 *     // Definir matrices para multiplicación
 *     float datos_a[6] = {1, 2, 3, 4, 5, 6};    // Matriz 2x3
 *     float datos_b[6] = {7, 8, 9, 10, 11, 12}; // Matriz 3x2
 *     float datos_c[4];                          // Matriz resultado 2x2
 *     
 *     MATRIZ matriz_a = {2, 3, datos_a};
 *     MATRIZ matriz_b = {3, 2, datos_b};
 *     MATRIZ matriz_c = {2, 2, datos_c};
 *     
 *     // Multiplicar matrices
 *     int resultado = nsdsp_math_api.product(&matriz_a, &matriz_b, &matriz_c);
 *     
 *     if (resultado == NSDSP_MATH_OK)
 *     {
 *         // Usar matriz resultado
 *         for (int i = 0; i < 4; i++)
 *         {
 *             printf("C[%d] = %f\n", i, datos_c[i]);
 *         }
 *     }
 *     
 *     // Definir matrices para suma/resta
 *     float datos_m1[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
 *     float datos_m2[9] = {9, 8, 7, 6, 5, 4, 3, 2, 1};
 *     float datos_suma[9];
 *     
 *     MATRIZ m1 = {3, 3, datos_m1};
 *     MATRIZ m2 = {3, 3, datos_m2};
 *     MATRIZ m_suma = {3, 3, datos_suma};
 *     
 *     // Sumar matrices (signo >= 0)
 *     resultado = nsdsp_math_api.suma(&m1, &m2, &m_suma, 1);
 *     
 *     // Restar matrices (signo < 0)
 *     resultado = nsdsp_math_api.suma(&m1, &m2, &m_suma, -1);
 * \endcode
 *
 * \subsection paso3_ann Paso 3e: Usar ANN (Patrón de Objetos)
 * \code
 *     // Definir arquitectura de red: 3 entradas, 4 neuronas ocultas, 2 salidas
 *     float w1_data[12] = {0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f,
 *                          0.7f, 0.8f, 0.9f, 1.0f, 1.1f, 1.2f};
 *     float b1_data[4] = {0.1f, 0.2f, 0.3f, 0.4f};
 *     
 *     float w2_data[8] = {0.1f, 0.2f, 0.3f, 0.4f,
 *                         0.5f, 0.6f, 0.7f, 0.8f};
 *     float b2_data[2] = {0.1f, 0.2f};
 *     
 *     MATRIZ pesos[2] = {{4, 3, w1_data}, {2, 4, w2_data}};
 *     MATRIZ bias[2] = {{4, 1, b1_data}, {2, 1, b2_data}};
 *     
 *     // Crear red neuronal con función de activación RELU
 *     ANN_SERVICE red = ann_api.get_ann(2, RELU, pesos, bias);
 *     
 *     // Preparar datos de entrada
 *     float input_data[3] = {1.0f, 0.5f, -0.3f};
 *     red.x0.pmatriz = input_data;
 *     
 *     // Preparar buffer de salida
 *     float output_data[2];
 *     red.y0.pmatriz = output_data;
 *     
 *     // Procesar datos (forward pass se implementaría en otra función)
 *     // ann_api.forward(&red);
 * \endcode
 *
 * \subsection paso4 Paso 4: Finalizar
 * \code
 *     return 0;
 * }
 * \endcode
 *
 * \section ejemplo_completo Ejemplo Completo
 *
 * \code
 * #include "nsdsp.h"
 * #include <math.h>
 * 
 * // Generador de señal senoidal con ruido
 * float generar_senal(int n)
 * {
 *     float senal = sin(2.0f * 3.14159f * n / 100.0f);
 *     float ruido = ((float)rand() / RAND_MAX - 0.5f) * 0.1f;
 *     return senal + ruido;
 * }
 * 
 * int main(void)
 * {
 *     RT_MOMENTOS_SERVICE srv_momentos;
 *     DWT_OBJECT dwt_obj;
 *     FIR_FILTER_OBJECT filtro;
 *     float coefs[5] = {0.2f, 0.2f, 0.2f, 0.2f, 0.2f};
 *     float z_buffer[5];
 *     float muestra, salida_fir;
 *     int i;
 *     
 *     // Matrices para ejemplo de multiplicación
 *     float datos_m1[6] = {1, 2, 3, 4, 5, 6};
 *     float datos_m2[6] = {1, 0, 0, 1, 1, 0};
 *     float datos_resultado[4];
 *     MATRIZ m1 = {2, 3, datos_m1};
 *     MATRIZ m2 = {3, 2, datos_m2};
 *     MATRIZ m_res = {2, 2, datos_resultado};
 *     
 *     // Matrices para ejemplo de suma
 *     float datos_s1[4] = {1, 2, 3, 4};
 *     float datos_s2[4] = {5, 6, 7, 8};
 *     float datos_suma[4];
 *     MATRIZ ms1 = {2, 2, datos_s1};
 *     MATRIZ ms2 = {2, 2, datos_s2};
 *     MATRIZ ms_res = {2, 2, datos_suma};
 *     
 *     // Red neuronal: 2 entradas, 3 ocultas, 1 salida
 *     float w1_ann[6] = {0.5f, -0.3f, 0.2f, 0.8f, -0.1f, 0.4f};
 *     float b1_ann[3] = {0.1f, 0.2f, -0.1f};
 *     float w2_ann[3] = {0.6f, 0.3f, -0.5f};
 *     float b2_ann[1] = {0.15f};
 *     MATRIZ pesos_ann[2] = {{3, 2, w1_ann}, {1, 3, w2_ann}};
 *     MATRIZ bias_ann[2] = {{3, 1, b1_ann}, {1, 1, b2_ann}};
 *     ANN_SERVICE red_neuronal;
 *     float entrada_ann[2] = {0.5f, 0.8f};
 *     float salida_ann[1];
 *     
 *     // Inicializar librería completa
 *     Init_NSDSP();
 *     
 *     // Configurar todos los recursos
 *     srv_momentos = pse.suscribe_rt_momentos();
 *     dwt_api.get_dwt(&dwt_obj);
 *     filtro = fir_api.get_fir(5, coefs, z_buffer);
 *     red_neuronal = ann_api.get_ann(2, RELU, pesos_ann, bias_ann);
 *     red_neuronal.x0.pmatriz = entrada_ann;
 *     red_neuronal.y0.pmatriz = salida_ann;
 *     
 *     if (srv_momentos == NONE)
 *     {
 *         printf("Error: No hay servicios de momentos disponibles\n");
 *         return -1;
 *     }
 *     
 *     // Ejemplo de multiplicación de matrices
 *     if (nsdsp_math_api.product(&m1, &m2, &m_res) == NSDSP_MATH_OK)
 *     {
 *         printf("Resultado de multiplicación matricial:\n");
 *         for (i = 0; i < 4; i++)
 *         {
 *             printf("  Producto[%d] = %.2f\n", i, datos_resultado[i]);
 *         }
 *     }
 *     
 *     // Ejemplo de suma de matrices
 *     if (nsdsp_math_api.suma(&ms1, &ms2, &ms_res, 1) == NSDSP_MATH_OK)
 *     {
 *         printf("Resultado de suma matricial:\n");
 *         for (i = 0; i < 4; i++)
 *         {
 *             printf("  Suma[%d] = %.2f\n", i, datos_suma[i]);
 *         }
 *     }
 *     
 *     // Procesar con red neuronal
 *     printf("Red neuronal configurada:\n");
 *     printf("  Entrada: [%.2f, %.2f]\n", entrada_ann[0], entrada_ann[1]);
 *     printf("  Capas: %u\n", red_neuronal.net.levels);
 *     printf("  Función activación: %s\n", 
 *            red_neuronal.trigger == RELU ? "RELU" : "OTRA");
 *     
 *     // Procesar 1000 muestras
 *     for (i = 0; i < 1000; i++)
 *     {
 *         // Generar señal
 *         muestra = generar_senal(i);
 *         
 *         // Procesar con todos los módulos
 *         pse.compute_rt_momentos(srv_momentos, muestra);
 *         dwt_api.dwt(muestra, &dwt_obj);
 *         salida_fir = fir_api.fir_filter(muestra, &filtro);
 *         
 *         // Mostrar resultados cada 200 muestras
 *         if (i % 200 == 199)
 *         {
 *             printf("\n=== Muestra %d ===\n", i + 1);
 *             
 *             // Momentos estadísticos
 *             printf("Momentos - Media: %.3f, Var: %.3f\n",
 *                    nsdsp_statistical_objects[srv_momentos].media,
 *                    nsdsp_statistical_objects[srv_momentos].varianza);
 *             
 *             // Wavelet
 *             printf("DWT - Aprox: %.3f, Det[0]: %.3f, Det[1]: %.3f\n",
 *                    dwt_obj.yout[WAVELET_LEVELS],
 *                    dwt_obj.yout[0], dwt_obj.yout[1]);
 *             
 *             // FIR
 *             printf("FIR - Salida filtrada: %.3f\n", salida_fir);
 *         }
 *     }
 *     
 *     // Liberar recursos
 *     pse.unsuscribe_rt_momentos(srv_momentos);
 *     
 *     return 0;
 * }
 * \endcode
 *
 * \section configuracion Configuración Avanzada
 *
 * \subsection config_rt_momentos Configuración RT_Momentos
 * En rt_momentos.h:
 * \code
 * #define MAX_RT_MOMENTOS 4    // Máximo número de servicios concurrentes
 * #define N_MA            64   // Ventana de la media móvil
 * \endcode
 *
 * \subsection config_dwt Configuración DWT
 * En dwt.h:
 * \code
 * #define LAGRANGE_M      3     // Parámetro M para filtros Lagrange
 * #define WAVELET_LEVELS  2     // Número de niveles de descomposición
 * 
 * // Seleccionar tipo de wavelet (solo uno activo):
 * #define LAGRANGE              // Filtros Lagrange halfband
 * //#define DB4                 // Daubechies 4
 * //#define DB8                 // Daubechies 8
 * \endcode
 *
 * \subsection config_fir Configuración FIR Filter
 * En fir_filter.h:
 * \code
 * #define MAX_FIR_LENGTH  128   // Longitud máxima de filtro FIR
 * \endcode
 *
 * \subsection config_math Configuración NSDSP Math
 * En nsdsp_math.h:
 * \code
 * #define NSDSP_MATH_OK   0     // Código de retorno: operación exitosa
 * #define NSDSP_MATH_KO  -1     // Código de retorno: error en operación
 * \endcode
 *
 * \subsection config_ann Configuración ANN
 * En ann.h:
 * \code
 * #define LMAX  4   // Número máximo de capas de la red
 * 
 * // Funciones de activación disponibles:
 * typedef enum {
 *     SIGMOID,  // Función sigmoide
 *     TANH,     // Tangente hiperbólica
 *     RELU,     // Rectified Linear Unit
 *     LEAK,     // Leaky ReLU
 *     SOFT,     // Softmax
 *     STEP      // Función escalón
 * } ANN_TRIGGER;
 * \endcode
 *
 * \section notas Notas Importantes
 *
 * - **Primeras N_MA muestras**: Los resultados de RT_Momentos no son válidos hasta procesar al menos N_MA (64) muestras
 * - **División por cero**: Es normal que compute_rt_momentos() retorne RT_MOMENTOS_KO en las primeras muestras cuando la varianza es 0
 * - **Memoria estática**: No se usa malloc/free, toda la memoria está preasignada
 * - **Thread safety**: La librería NO es thread-safe. Cada thread debe usar servicios/objetos diferentes
 * - **Orden de inicialización**: Init_NSDSP() debe llamarse antes que cualquier API específica
 * - **Objetos DWT/FIR**: No requieren liberación explícita, son automáticos
 * - **Validación de matrices**: NSDSP Math valida dimensiones y punteros antes de operar
 * - **Redes neuronales**: Los pesos y bias deben ser definidos antes de crear el servicio ANN
 * - **Límite de capas ANN**: Máximo LMAX (4) capas en una red neuronal
 *
 * \section compilacion Compilación
 *
 * \subsection debug Modo Debug
 * \code
 * gcc -DDEBUG -o test_nsdsp *.c -lm
 * \endcode
 * En modo DEBUG se incluyen todos los tests unitarios.
 *
 * \subsection release Modo Release
 * \code
 * gcc -o nsdsp_app *.c -lm
 * \endcode
 * En modo Release solo se compila el código de producción.
 *
 * \section extension Extensión de la Librería
 *
 * Para añadir nuevos recursos a NSDSP:
 * 1. Crear el módulo siguiendo uno de los patrones existentes
 * 2. Añadir el header del nuevo recurso en nsdsp.h
 * 3. Llamar a Init_[nuevo_recurso]() desde Init_NSDSP() si requiere inicialización
 * 4. Crear tests unitarios en test_[nuevo_recurso].c
 * 5. Documentar el nuevo recurso en esta página
 * 6. Si usa API con punteros a funciones, inicializarlos en su función Init
 *
 * \section testing Tests Unitarios
 *
 * La librería incluye tests unitarios completos:
 * - test_rt_momentos.c: Tests para cálculo de momentos
 * - test_dwt.c: Tests para transformada wavelet
 * - test_fir_filter.c: Tests para filtros FIR
 * - test_lagrange_halfband.c: Tests para filtros Lagrange
 * - test_nsdsp_math.c: Tests para operaciones matemáticas
 * - test_ann.c: Tests para redes neuronales artificiales
 *
 * Los tests se ejecutan automáticamente en modo DEBUG y generan archivos de log con resultados detallados.
 *
 * \author Dr. Carlos Romero
 * \version 2.2
 * \date 14/09/2025
 * 
 * \section historial_mainpage Historial de cambios
 * | Fecha | Autor | Versión | Descripción |
 * |:-----:|:-----:|:-------:|:------------|
 * | 12/07/2025 | Dr. Carlos Romero | 1.0 | Primera versión |
 * | 30/08/2025 | Dr. Carlos Romero | 2.0 | Actualización completa con DWT, FIR y Lagrange |
 * | 13/09/2025 | Dr. Carlos Romero | 2.1 | Añadido módulo NSDSP Math con operaciones matriciales |
 * | 14/09/2025 | Dr. Carlos Romero | 2.2 | Añadido módulo ANN para redes neuronales artificiales |
 * 
 * \copyright ZGR R&D AIE
 */